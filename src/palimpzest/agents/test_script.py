import unittest

from palimpzest.agents.planner_agent import PlannerAgent

class TestCodeExtractor(unittest.TestCase):
    def setUp(self):
        self.agent = PlannerAgent()
        self.agent.relevant_issue_code = "\n[start of astropy/utils/metadata.py]\n1 # Licensed under a 3-clause BSD style license - see LICENSE.rst\n2 \"\"\"\n3 This module contains helper functions and classes for handling metadata.\n4 \"\"\"\n5 \n6 from functools import wraps\n7 \n8 import warnings\n9 \n10 from collections import OrderedDict\n11 from collections.abc import Mapping\n12 from copy import deepcopy\n13 \n14 import numpy as np\n15 from astropy.utils.exceptions import AstropyWarning\n16 from astropy.utils.misc import dtype_bytes_or_chars\n17 \n18 \n19 __all__ = ['MergeConflictError', 'MergeConflictWarning', 'MERGE_STRATEGIES',\n20            'common_dtype', 'MergePlus', 'MergeNpConcatenate', 'MergeStrategy',\n21            'MergeStrategyMeta', 'enable_merge_strategies', 'merge', 'MetaData',\n22            'MetaAttribute']\n23 \n24 \n25 class MergeConflictError(TypeError):\n26     pass\n27 \n28 \n29 class MergeConflictWarning(AstropyWarning):\n30     pass\n31 \n32 \n33 MERGE_STRATEGIES = []\n34 \n35 \n36 def common_dtype(arrs):\n37     \"\"\"\n38     Use numpy to find the common dtype for a list of ndarrays.\n39 \n40     Only allow arrays within the following fundamental numpy data types:\n41     ``np.bool_``, ``np.object_``, ``np.number``, ``np.character``, ``np.void``\n42 \n43     Parameters\n44     ----------\n45     arrs : list of ndarray\n46         Arrays for which to find the common dtype\n47 \n48     Returns\n49     -------\n50     dtype_str : str\n51         String representation of dytpe (dtype ``str`` attribute)\n52     \"\"\"\n53     def dtype(arr):\n54         return getattr(arr, 'dtype', np.dtype('O'))\n55 \n56     np_types = (np.bool_, np.object_, np.number, np.character, np.void)\n57     uniq_types = set(tuple(issubclass(dtype(arr).type, np_type) for np_type in np_types)\n58                      for arr in arrs)\n59     if len(uniq_types) > 1:\n60         # Embed into the exception the actual list of incompatible types.\n61         incompat_types = [dtype(arr).name for arr in arrs]\n62         tme = MergeConflictError(f'Arrays have incompatible types {incompat_types}')\n63         tme._incompat_types = incompat_types\n64         raise tme\n65 \n66     arrs = [np.empty(1, dtype=dtype(arr)) for arr in arrs]\n67 \n68     # For string-type arrays need to explicitly fill in non-zero\n69     # values or the final arr_common = .. step is unpredictable.\n70     for i, arr in enumerate(arrs):\n71         if arr.dtype.kind in ('S', 'U'):\n72             arrs[i] = [('0' if arr.dtype.kind == 'U' else b'0') *\n73                        dtype_bytes_or_chars(arr.dtype)]\n74 \n75     arr_common = np.array([arr[0] for arr in arrs])\n76     return arr_common.dtype.str\n77 \n78 \n79 class MergeStrategyMeta(type):\n80     \"\"\"\n81     Metaclass that registers MergeStrategy subclasses into the\n82     MERGE_STRATEGIES registry.\n83     \"\"\"\n84 \n85     def __new__(mcls, name, bases, members):\n86         cls = super().__new__(mcls, name, bases, members)\n87 \n88         # Wrap ``merge`` classmethod to catch any exception and re-raise as\n89         # MergeConflictError.\n90         if 'merge' in members and isinstance(members['merge'], classmethod):\n91             orig_merge = members['merge'].__func__\n92 \n93             @wraps(orig_merge)\n94             def merge(cls, left, right):\n95                 try:\n96                     return orig_merge(cls, left, right)\n97                 except Exception as err:\n98                     raise MergeConflictError(err)\n99 \n100             cls.merge = classmethod(merge)\n101 \n102         # Register merging class (except for base MergeStrategy class)\n103         if 'types' in members:\n104             types = members['types']\n105             if isinstance(types, tuple):\n106                 types = [types]\n107             for left, right in reversed(types):\n108                 MERGE_STRATEGIES.insert(0, (left, right, cls))\n109 \n110         return cls\n111 \n112 \n113 class MergeStrategy(metaclass=MergeStrategyMeta):\n114     \"\"\"\n115     Base class for defining a strategy for merging metadata from two\n116     sources, left and right, into a single output.\n117 \n118     The primary functionality for the class is the ``merge(cls, left, right)``\n119     class method.  This takes ``left`` and ``right`` side arguments and\n120     returns a single merged output.\n121 \n122     The first class attribute is ``types``.  This is defined as a list of\n123     (left_types, right_types) tuples that indicate for which input types the\n124     merge strategy applies.  In determining whether to apply this merge\n125     strategy to a pair of (left, right) objects, a test is done:\n126     ``isinstance(left, left_types) and isinstance(right, right_types)``.  For\n127     example::\n128 \n129       types = [(np.ndarray, np.ndarray),  # Two ndarrays\n130                (np.ndarray, (list, tuple)),  # ndarray and (list or tuple)\n131                ((list, tuple), np.ndarray)]  # (list or tuple) and ndarray\n132 \n133     As a convenience, ``types`` can be defined as a single two-tuple instead of\n134     a list of two-tuples, e.g. ``types = (np.ndarray, np.ndarray)``.\n135 \n136     The other class attribute is ``enabled``, which defaults to ``False`` in\n137     the base class.  By defining a subclass of ``MergeStrategy`` the new merge\n138     strategy is automatically registered to be available for use in\n139     merging. However, by default the new merge strategy is *not enabled*.  This\n140     prevents inadvertently changing the behavior of unrelated code that is\n141     performing metadata merge operations.\n142 \n143     In most cases (particularly in library code that others might use) it is\n144     recommended to leave custom strategies disabled and use the\n145     `~astropy.utils.metadata.enable_merge_strategies` context manager to locally\n146     enable the desired strategies.  However, if one is confident that the\n147     new strategy will not produce unexpected behavior, then one can globally\n148     enable it by setting the ``enabled`` class attribute to ``True``.\n149 \n150     Examples\n151     --------\n152     Here we define a custom merge strategy that takes an int or float on\n153     the left and right sides and returns a list with the two values.\n154 \n155       >>> from astropy.utils.metadata import MergeStrategy\n156       >>> class MergeNumbersAsList(MergeStrategy):\n157       ...     types = ((int, float), (int, float))  # (left_types, right_types)\n158       ...\n159       ...     @classmethod\n160       ...     def merge(cls, left, right):\n161       ...         return [left, right]\n162 \n163     \"\"\"\n164     # Set ``enabled = True`` to globally enable applying this merge strategy.\n165     # This is not generally recommended.\n166     enabled = False\n167 \n168     # types = [(left_types, right_types), ...]\n169 \n170 \n171 class MergePlus(MergeStrategy):\n172     \"\"\"\n173     Merge ``left`` and ``right`` objects using the plus operator.  This\n174     merge strategy is globally enabled by default.\n175     \"\"\"\n176     types = [(list, list), (tuple, tuple)]\n177     enabled = True\n178 \n179     @classmethod\n180     def merge(cls, left, right):\n181         return left + right\n182 \n183 \n184 class MergeNpConcatenate(MergeStrategy):\n185     \"\"\"\n186     Merge ``left`` and ``right`` objects using np.concatenate.  This\n187     merge strategy is globally enabled by default.\n188 \n189     This will upcast a list or tuple to np.ndarray and the output is\n190     always ndarray.\n191     \"\"\"\n192     types = [(np.ndarray, np.ndarray),\n193              (np.ndarray, (list, tuple)),\n194              ((list, tuple), np.ndarray)]\n195     enabled = True\n196 \n197     @classmethod\n198     def merge(cls, left, right):\n199         left, right = np.asanyarray(left), np.asanyarray(right)\n200         common_dtype([left, right])  # Ensure left and right have compatible dtype\n201         return np.concatenate([left, right])\n202 \n203 \n204 def _both_isinstance(left, right, cls):\n205     return isinstance(left, cls) and isinstance(right, cls)\n206 \n207 \n208 def _not_equal(left, right):\n209     try:\n210         return bool(left != right)\n211     except Exception:\n212         return True\n213 \n214 \n215 class _EnableMergeStrategies:\n216     def __init__(self, *merge_strategies):\n217         self.merge_strategies = merge_strategies\n218         self.orig_enabled = {}\n219         for left_type, right_type, merge_strategy in MERGE_STRATEGIES:\n220             if issubclass(merge_strategy, merge_strategies):\n221                 self.orig_enabled[merge_strategy] = merge_strategy.enabled\n222                 merge_strategy.enabled = True\n223 \n224     def __enter__(self):\n225         pass\n226 \n227     def __exit__(self, type, value, tb):\n228         for merge_strategy, enabled in self.orig_enabled.items():\n229             merge_strategy.enabled = enabled\n230 \n231 \n232 def enable_merge_strategies(*merge_strategies):\n233     \"\"\"\n234     Context manager to temporarily enable one or more custom metadata merge\n235     strategies.\n236 \n237     Examples\n238     --------\n239     Here we define a custom merge strategy that takes an int or float on\n240     the left and right sides and returns a list with the two values.\n241 \n242       >>> from astropy.utils.metadata import MergeStrategy\n243       >>> class MergeNumbersAsList(MergeStrategy):\n244       ...     types = ((int, float),  # left side types\n245       ...              (int, float))  # right side types\n246       ...     @classmethod\n247       ...     def merge(cls, left, right):\n248       ...         return [left, right]\n249 \n250     By defining this class the merge strategy is automatically registered to be\n251     available for use in merging. However, by default new merge strategies are\n252     *not enabled*.  This prevents inadvertently changing the behavior of\n253     unrelated code that is performing metadata merge operations.\n254 \n255     In order to use the new merge strategy, use this context manager as in the\n256     following example::\n257 \n258       >>> from astropy.table import Table, vstack\n259       >>> from astropy.utils.metadata import enable_merge_strategies\n260       >>> t1 = Table([[1]], names=['a'])\n261       >>> t2 = Table([[2]], names=['a'])\n262       >>> t1.meta = {'m': 1}\n263       >>> t2.meta = {'m': 2}\n264       >>> with enable_merge_strategies(MergeNumbersAsList):\n265       ...    t12 = vstack([t1, t2])\n266       >>> t12.meta['m']\n267       [1, 2]\n268 \n269     One can supply further merge strategies as additional arguments to the\n270     context manager.\n271 \n272     As a convenience, the enabling operation is actually done by checking\n273     whether the registered strategies are subclasses of the context manager\n274     arguments.  This means one can define a related set of merge strategies and\n275     then enable them all at once by enabling the base class.  As a trivial\n276     example, *all* registered merge strategies can be enabled with::\n277 \n278       >>> with enable_merge_strategies(MergeStrategy):\n279       ...    t12 = vstack([t1, t2])\n280 \n281     Parameters\n282     ----------\n283     *merge_strategies : `~astropy.utils.metadata.MergeStrategy`\n284         Merge strategies that will be enabled.\n285 \n286     \"\"\"\n287 \n288     return _EnableMergeStrategies(*merge_strategies)\n289 \n290 \n291 def _warn_str_func(key, left, right):\n292     out = ('Cannot merge meta key {0!r} types {1!r}'\n293            ' and {2!r}, choosing {0}={3!r}'\n294            .format(key, type(left), type(right), right))\n295     return out\n296 \n297 \n298 def _error_str_func(key, left, right):\n299     out = f'Cannot merge meta key {key!r} types {type(left)!r} and {type(right)!r}'\n300     return out\n301 \n302 \n303 def merge(left, right, merge_func=None, metadata_conflicts='warn',\n304           warn_str_func=_warn_str_func,\n305           error_str_func=_error_str_func):\n306     \"\"\"\n307     Merge the ``left`` and ``right`` metadata objects.\n308 \n309     This is a simplistic and limited implementation at this point.\n310     \"\"\"\n311     if not _both_isinstance(left, right, dict):\n312         raise MergeConflictError('Can only merge two dict-based objects')\n313 \n314     out = deepcopy(left)\n315 \n316     for key, val in right.items():\n317         # If no conflict then insert val into out dict and continue\n318         if key not in out:\n319             out[key] = deepcopy(val)\n320             continue\n321 \n322         # There is a conflict that must be resolved\n323         if _both_isinstance(left[key], right[key], dict):\n324             out[key] = merge(left[key], right[key], merge_func,\n325                              metadata_conflicts=metadata_conflicts)\n326 \n327         else:\n328             try:\n329                 if merge_func is None:\n330                     for left_type, right_type, merge_cls in MERGE_STRATEGIES:\n331                         if not merge_cls.enabled:\n332                             continue\n333                         if (isinstance(left[key], left_type) and\n334                                 isinstance(right[key], right_type)):\n335                             out[key] = merge_cls.merge(left[key], right[key])\n336                             break\n337                     else:\n338                         raise MergeConflictError\n339                 else:\n340                     out[key] = merge_func(left[key], right[key])\n341             except MergeConflictError:\n342 \n343                 # Pick the metadata item that is not None, or they are both not\n344                 # None, then if they are equal, there is no conflict, and if\n345                 # they are different, there is a conflict and we pick the one\n346                 # on the right (or raise an error).\n347 \n348                 if left[key] is None:\n349                     # This may not seem necessary since out[key] gets set to\n350                     # right[key], but not all objects support != which is\n351                     # needed for one of the if clauses.\n352                     out[key] = right[key]\n353                 elif right[key] is None:\n354                     out[key] = left[key]\n355                 elif _not_equal(left[key], right[key]):\n356                     if metadata_conflicts == 'warn':\n357                         warnings.warn(warn_str_func(key, left[key], right[key]),\n358                                       MergeConflictWarning)\n359                     elif metadata_conflicts == 'error':\n360                         raise MergeConflictError(error_str_func(key, left[key], right[key]))\n361                     elif metadata_conflicts != 'silent':\n362                         raise ValueError('metadata_conflicts argument must be one '\n363                                          'of \"silent\", \"warn\", or \"error\"')\n364                     out[key] = right[key]\n365                 else:\n366                     out[key] = right[key]\n367 \n368     return out\n369 \n370 \n371 class MetaData:\n372     \"\"\"\n373     A descriptor for classes that have a ``meta`` property.\n374 \n375     This can be set to any valid `~collections.abc.Mapping`.\n376 \n377     Parameters\n378     ----------\n379     doc : `str`, optional\n380         Documentation for the attribute of the class.\n381         Default is ``\"\"``.\n382 \n383         .. versionadded:: 1.2\n384 \n385     copy : `bool`, optional\n386         If ``True`` the the value is deepcopied before setting, otherwise it\n387         is saved as reference.\n388         Default is ``True``.\n389 \n390         .. versionadded:: 1.2\n391     \"\"\"\n392 \n393     def __init__(self, doc=\"\", copy=True):\n394         self.__doc__ = doc\n395         self.copy = copy\n396 \n397     def __get__(self, instance, owner):\n398         if instance is None:\n399             return self\n400         if not hasattr(instance, '_meta'):\n401             instance._meta = OrderedDict()\n402         return instance._meta\n403 \n404     def __set__(self, instance, value):\n405         if value is None:\n406             instance._meta = OrderedDict()\n407         else:\n408             if isinstance(value, Mapping):\n409                 if self.copy:\n410                     instance._meta = deepcopy(value)\n411                 else:\n412                     instance._meta = value\n413             else:\n414                 raise TypeError(\"meta attribute must be dict-like\")\n415 \n416 \n417 class MetaAttribute:\n418     \"\"\"\n419     Descriptor to define custom attribute which gets stored in the object\n420     ``meta`` dict and can have a defined default.\n421 \n422     This descriptor is intended to provide a convenient way to add attributes\n423     to a subclass of a complex class such as ``Table`` or ``NDData``.\n424 \n425     This requires that the object has an attribute ``meta`` which is a\n426     dict-like object.  The value of the MetaAttribute will be stored in a\n427     new dict meta['__attributes__'] that is created when required.\n428 \n429     Classes that define MetaAttributes are encouraged to support initializing\n430     the attributes via the class ``__init__``.  For example::\n431 \n432         for attr in list(kwargs):\n433             descr = getattr(self.__class__, attr, None)\n434             if isinstance(descr, MetaAttribute):\n435                 setattr(self, attr, kwargs.pop(attr))\n436 \n437     The name of a ``MetaAttribute`` cannot be the same as any of the following:\n438 \n439     - Keyword argument in the owner class ``__init__``\n440     - Method or attribute of the \"parent class\", where the parent class is\n441       taken to be ``owner.__mro__[1]``.\n442 \n443     :param default: default value\n444 \n445     \"\"\"\n446     def __init__(self, default=None):\n447         self.default = default\n448 \n449     def __get__(self, instance, owner):\n450         # When called without an instance, return self to allow access\n451         # to descriptor attributes.\n452         if instance is None:\n453             return self\n454 \n455         # If default is None and value has not been set already then return None\n456         # without doing touching meta['__attributes__'] at all. This helps e.g.\n457         # with the Table._hidden_columns attribute so it doesn't auto-create\n458         # meta['__attributes__'] always.\n459         if (self.default is None\n460                 and self.name not in instance.meta.get('__attributes__', {})):\n461             return None\n462 \n463         # Get the __attributes__ dict and create if not there already.\n464         attributes = instance.meta.setdefault('__attributes__', {})\n465         try:\n466             value = attributes[self.name]\n467         except KeyError:\n468             if self.default is not None:\n469                 attributes[self.name] = deepcopy(self.default)\n470             # Return either specified default or None\n471             value = attributes.get(self.name)\n472         return value\n473 \n474     def __set__(self, instance, value):\n475         # Get the __attributes__ dict and create if not there already.\n476         attributes = instance.meta.setdefault('__attributes__', {})\n477         attributes[self.name] = value\n478 \n479     def __delete__(self, instance):\n480         # Remove this attribute from meta['__attributes__'] if it exists.\n481         if '__attributes__' in instance.meta:\n482             attrs = instance.meta['__attributes__']\n483             if self.name in attrs:\n484                 del attrs[self.name]\n485             # If this was the last attribute then remove the meta key as well\n486             if not attrs:\n487                 del instance.meta['__attributes__']\n488 \n489     def __set_name__(self, owner, name):\n490         import inspect\n491         params = [param.name for param in inspect.signature(owner).parameters.values()\n492                   if param.kind not in (inspect.Parameter.VAR_KEYWORD,\n493                                         inspect.Parameter.VAR_POSITIONAL)]\n494 \n495         # Reject names from existing params or best guess at parent class\n496         if name in params or hasattr(owner.__mro__[1], name):\n497             raise ValueError(f'{name} not allowed as {self.__class__.__name__}')\n498 \n499         self.name = name\n500 \n501     def __repr__(self):\n502         return f'<{self.__class__.__name__} name={self.name} default={self.default}>'\n503 \n[end of astropy/utils/metadata.py]\n"

    def test_valid_file_and_range(self):
        """Test extracting a valid range within a file"""
        result = self.agent.get_range("metadata.py", '490', '499')
        expected = "         import inspect\n491         params = [param.name for param in inspect.signature(owner).parameters.values()\n492                   if param.kind not in (inspect.Parameter.VAR_KEYWORD,\n493                                         inspect.Parameter.VAR_POSITIONAL)]\n494 \n495         # Reject names from existing params or best guess at parent class\n496         if name in params or hasattr(owner.__mro__[1], name):\n497             raise ValueError(f'{name} not allowed as {self.__class__.__name__}')\n498 \n"
        self.assertEqual(result, expected)

    def test_get_classes_and_methods(self):
        result = self.agent.get_classes_and_methods("metadata.py")
        expected = '{\n    "MergeConflictError": [],\n    "MergeConflictWarning": [],\n    "MergeStrategyMeta": ["__new__"],\n    "MergeStrategy": ["merge"],\n    "MergePlus": ["merge"],\n    "MergeNpConcatenate": ["merge"],\n    "MetaData": ["__init__", "__get__", "__set__"],\n    "MetaAttribute": ["__init__", "__get__", "__set__", "__delete__", "__set_name__", "__repr__"]\n}'
        self.assertEqual(result, expected)

if __name__ == "__main__":
    unittest.main()
